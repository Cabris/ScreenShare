package com.stream.source;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.*;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.concurrent.ConcurrentLinkedQueue;
import com.comman.*;

public class StreamReceiver extends StreamSource {

	Socket clientSocket;
	String ipAddress;
	int port;
	InputStream inputStream;
	boolean isEof;
	ReceiveThread receiveThread;

	long total = 0;
	boolean firstPacket = false;
	ByteBuffer byteBuffer;
	ByteBuffer lengthBuffer;
	protected int targetLength = 0;
	protected int currentLength = 0;
	int maxBufferSize = 10000000;
	BufferedInputStream inFromServer;

	public StreamReceiver(String ip, int port) {
		this.ipAddress = ip;
		this.port = port;
		queue = new ConcurrentLinkedQueue<byte[]>();
		receiveThread = new ReceiveThread();
	}

	public void Connect() {
		receiveThread.start();
	}

	public void onDestory() {
		receiveThread.interrupt();
	}

	public String getIpAddress() {
		return ipAddress;
	}

	public void setIpAddress(String ipAddress) {
		this.ipAddress = ipAddress;
	}

	public int getPort() {
		return port;
	}

	public void setPort(int port) {
		this.port = port;
	}

	@Override
	public boolean isEOS() {
		return isEof;
	}

	

	protected int updateLength() throws Exception {
		int bytesRead;
		byte[] lengthData = new byte[4];
		lengthBuffer.clear();
		int readed = 0;
		while (true) {
			bytesRead = inputStream.read(lengthData);
			if (bytesRead > 0) {
				lengthBuffer.put(lengthData, 0, bytesRead);
				readed += bytesRead;
			}
			if (readed == lengthData.length)
				break;
		}
		lengthBuffer.flip();
		lengthBuffer.get(lengthData);
		targetLength = BitConverter.toInt32(lengthData, 0);
		return bytesRead;
	}

	protected void fillBuffer() throws Exception {
		int bytesRead = 0;
		currentLength=0;
		byte[] fillInBuffer = new byte[targetLength];
		byteBuffer.clear();
		while(true){
			bytesRead = inputStream.read(fillInBuffer);
			if(bytesRead>0){
				byteBuffer.put(fillInBuffer,0,bytesRead);
				currentLength+=bytesRead;
			}
			if(currentLength==targetLength)
				break;
		}
		byteBuffer.flip();
		byteBuffer.get(fillInBuffer);
		gotPacket(fillInBuffer);
	}

	protected void gotPacket(byte[] packet) {
		if (!firstPacket) {
			extractSPS_PPS(packet);
			firstPacket = true;
		} else {
			total += packet.length;
			enqueue(packet);
		}
	}

	private void extractSPS_PPS(byte[] packet) {
		byte[] SPS_PPS, firstFrame;
		byte[] preCode = new byte[] { 0x0, 0x0, 0x0, 0x1 };
		byte[] uselessCode = new byte[] { 0x0, 0x0, 0x1 };
		int fstP = -1, secP = -1;
		for (int i = 3; i < packet.length; i++) {
			if (isMatch(packet, uselessCode, i)) {
				if (fstP < 0)
					fstP = i - 2;
				if (secP < 0)
					secP = i;
				if (fstP > 0 && secP > 0)
					break;
			}
		}
		try {
			if (!(fstP > 0 && secP > 0))
				throw new Exception("uselessCode: fstP=" + fstP + ", secP=" + secP);
		} catch (Exception e) {
			e.printStackTrace();
		}
		SPS_PPS = Arrays.copyOfRange(packet, 0, fstP);
		byte[] temp = Arrays.copyOfRange(packet, secP + 1, packet.length);
		firstFrame = new byte[preCode.length + temp.length];
		System.arraycopy(preCode, 0, firstFrame, 0, preCode.length);
		System.arraycopy(temp, 0, firstFrame, preCode.length, temp.length);
		enqueue(SPS_PPS);
		// Log.d("StreamReceiver", "SPS_PPS: " + SPS_PPS.length);
		enqueue(firstFrame);
		// Log.d("StreamReceiver", "firstFrame" + firstFrame.length);
	}

	private void enqueue(byte[] packet) {
		queue.add(packet);
	}

	private boolean isMatch(byte[] packet, byte[] uselessCode, int i) {
		return packet[i - 3] != 0x0 && packet[i - 2] == uselessCode[0] && packet[i - 1] == uselessCode[1]
				&& packet[i - 0] == uselessCode[2];
	}

	private class ReceiveThread extends Thread {

		public ReceiveThread() {
			byteBuffer = ByteBuffer.allocate(maxBufferSize);
			byteBuffer.clear();
			lengthBuffer = ByteBuffer.allocate(4);
			lengthBuffer.clear();
		}

		@Override
		public void run() {
			super.run();
			try {
				clientSocket = new Socket(ipAddress, port);
				clientSocket.setTcpNoDelay(true);
				inputStream = clientSocket.getInputStream();
				inFromServer = new BufferedInputStream(inputStream);
			} catch (Exception e) {
				e.printStackTrace();
			}

			try {
				targetLength = 0;
				currentLength = 0;
				while (!Thread.interrupted()) {
					int bytesRead = updateLength();
					if (bytesRead < 0) {
						interrupt();
						break;
					}
					fillBuffer();
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

}
