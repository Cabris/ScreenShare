package com.myapp.h264streamingviwer;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.*;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.concurrent.ConcurrentLinkedQueue;

import android.R.bool;
import android.R.integer;
import android.R.string;
import android.util.Log;
import com.comman.*;

public class StreamReceiver extends StreamSource {

	Socket clientSocket;
	String ipAddress;
	int port;
	BufferedReader inFromServer;
	InputStream inputStream;
	SubThread subThread;
	ReceiveThread receiveThread;

	public StreamReceiver(String ip, int port) {
		this.ipAddress = ip;
		this.port = port;
		queue = new ConcurrentLinkedQueue<byte[]>();
		subThread = new SubThread();
	}

	public void Connect() {
		subThread.start();
	}

	public void onDestory() {
		receiveThread.interrupt();
	}

	private class SubThread extends Thread {
		@Override
		public void run() {
			super.run();
			try {
				clientSocket = new Socket(ipAddress, port);
				inputStream = clientSocket.getInputStream();
				inFromServer = new BufferedReader(new InputStreamReader(inputStream));
				StartReceive();
			} catch (Exception e) {
				e.printStackTrace();
			}
		}

		private void StartReceive() {
			receiveThread = new ReceiveThread();
			receiveThread.start();
		}
	}

	private class ReceiveThread extends Thread {
		ByteBuffer byteBuffer;

		public ReceiveThread() {
			byteBuffer = ByteBuffer.allocate(800000);
			byteBuffer.clear();
		}

		int targetLength = 0;
		int currentLength = 0;
		long total = 0;
		boolean firstPacket = false;

		@Override
		public void run() {
			super.run();
			while (!Thread.interrupted()) {

				try {
					int bytesRead = 0;
					// bytesRead=inputStream.read(buffer);
					if (targetLength == currentLength) {// need to update the length
						if (targetLength > 0) {// get a packet
							byte[] packet = new byte[targetLength];
							Log.d("StreamReceiver", "byteBuffer.get: " + targetLength);
							byteBuffer.get(packet);
							gotPacket(packet);
							byteBuffer.clear();
						}
						byte[] lengthData = new byte[4];
						bytesRead = inputStream.read(lengthData);
						if (bytesRead <= 0) {// no input
							Log.d("StreamReceiver", "interrupted, total: " + total);
							Thread.interrupted();
							break;
						}
						targetLength = BitConverter.toInt32(lengthData, 0);
						Log.d("StreamReceiver", "targetLength updated: " + targetLength);
						currentLength = 0;
					} else {// fill in the buffer
						byte[] buffer = new byte[targetLength - currentLength];
						bytesRead = inputStream.read(buffer);
						Log.d("StreamReceiver", "targetLength: " + targetLength);
						Log.d("StreamReceiver", "currentLength: " + currentLength);
						Log.d("StreamReceiver", "fill buffer: " + bytesRead);
						currentLength += bytesRead;
						byteBuffer.put(buffer);
					}

				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		}

		private void gotPacket(byte[] packet) {
			if (!firstPacket) {
				byte[] SPS_PPS, firstFrame;
				byte[] preCode = new byte[] { 0x0, 0x0, 0x0, 0x1 };
				byte[] uselessCode = new byte[] { 0x0, 0x0, 0x1 };
				int fstP = -1, secP = -1;
				for (int i = 3; i < packet.length; i++) {
					if (packet[i - 3] != 0x0// 0
							&& packet[i - 2] == uselessCode[1]
							&& packet[i - 1] == uselessCode[2]
							&& packet[i - 0] == uselessCode[3]) {
						if (fstP < 0)
							fstP = i - 2;
						if (secP < 0)
							secP = i;
						if (fstP > 0 && secP > 0)
							break;
					}
				}

				try {
					if (!(fstP > 0 && secP > 0))
						throw new Exception("!(fstP>0&&secP>0)");
				} catch (Exception e) {
					e.printStackTrace();
				}
				SPS_PPS=Arrays.copyOfRange(packet, 0, fstP);
				byte[] temp=Arrays.copyOfRange(packet, secP+1, packet.length);
				firstFrame=new byte[preCode.length+temp.length];
				System.arraycopy(preCode,0,firstFrame,0,preCode.length);
				System.arraycopy(temp,0,firstFrame,preCode.length,temp.length);
				queue.add(SPS_PPS);
				Log.d("StreamReceiver", "SPS_PPS: " + SPS_PPS.length);
				queue.add(firstFrame);
				Log.d("StreamReceiver", "firstFrame" + firstFrame.length);
				firstPacket = true;
			} else {
				total += packet.length;
				queue.add(packet);
				Log.d("StreamReceiver", "packet: " + packet.length);
			}
		}
	}

	public String getIpAddress() {
		return ipAddress;
	}

	public void setIpAddress(String ipAddress) {
		this.ipAddress = ipAddress;
	}

	public int getPort() {
		return port;
	}

	public void setPort(int port) {
		this.port = port;
	}

}
